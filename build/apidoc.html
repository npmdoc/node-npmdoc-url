<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/defunctzombie/node-url#readme"

    >url (v0.11.0)</a>
</h1>
<h4>The core `url` packaged standalone for use with Browserify.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.url">module url</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url">
            function <span class="apidocSignatureSpan">url.</span>Url
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.format">
            function <span class="apidocSignatureSpan">url.</span>format
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.parse">
            function <span class="apidocSignatureSpan">url.</span>parse
            <span class="apidocSignatureSpan">(url, parseQueryString, slashesDenoteHost)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.resolve">
            function <span class="apidocSignatureSpan">url.</span>resolve
            <span class="apidocSignatureSpan">(source, relative)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.resolveObject">
            function <span class="apidocSignatureSpan">url.</span>resolveObject
            <span class="apidocSignatureSpan">(source, relative)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">url.</span>Url.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">url.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.url.Url">module url.Url</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url.Url">
            function <span class="apidocSignatureSpan">url.</span>Url
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.url.Url.prototype">module url.Url.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url.prototype.format">
            function <span class="apidocSignatureSpan">url.Url.prototype.</span>format
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url.prototype.parse">
            function <span class="apidocSignatureSpan">url.Url.prototype.</span>parse
            <span class="apidocSignatureSpan">(url, parseQueryString, slashesDenoteHost)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url.prototype.parseHost">
            function <span class="apidocSignatureSpan">url.Url.prototype.</span>parseHost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url.prototype.resolve">
            function <span class="apidocSignatureSpan">url.Url.prototype.</span>resolve
            <span class="apidocSignatureSpan">(relative)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url.prototype.resolveObject">
            function <span class="apidocSignatureSpan">url.Url.prototype.</span>resolveObject
            <span class="apidocSignatureSpan">(relative)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.url.util">module url.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.util.isNull">
            function <span class="apidocSignatureSpan">url.util.</span>isNull
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.util.isNullOrUndefined">
            function <span class="apidocSignatureSpan">url.util.</span>isNullOrUndefined
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.util.isObject">
            function <span class="apidocSignatureSpan">url.util.</span>isObject
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.util.isString">
            function <span class="apidocSignatureSpan">url.util.</span>isString
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.url" id="apidoc.module.url">module url</a></h1>


    <h2>
        <a href="#apidoc.element.url.Url" id="apidoc.element.url.Url">
        function <span class="apidocSignatureSpan">url.</span>Url
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.format" id="apidoc.element.url.format">
        function <span class="apidocSignatureSpan">url.</span>format
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function urlFormat(obj) {
  // ensure it&#x27;s an object, and not a string url.
  // If it&#x27;s an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the query string using the `querystring` module.
Defaults to `false`.

Pass `true` as the third argument to treat `//foo/bar` as
`{ host: &#x27;foo&#x27;, pathname: &#x27;/bar&#x27; }` rather than
`{ pathname: &#x27;//foo/bar&#x27; }`. Defaults to `false`.

### url.<span class="apidocCodeKeywordSpan">format</span>(urlObj)

Take a parsed URL object, and return a formatted URL string.

* `href` will be ignored.
* `protocol` is treated the same with or without the trailing `:` (colon).
* The protocols `http`, `https`, `ftp`, `gopher`, `file` will be
  postfixed with `://` (colon-slash-slash).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.parse" id="apidoc.element.url.parse">
        function <span class="apidocSignatureSpan">url.</span>parse
        <span class="apidocSignatureSpan">(url, parseQueryString, slashesDenoteHost)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url &#x26;&#x26; util.isObject(url) &#x26;&#x26; url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `hash`: The &#x27;fragment&#x27; portion of the URL including the pound-sign.

    Example: `&#x27;#hash&#x27;`

The following methods are provided by the URL module:

### url.<span class="apidocCodeKeywordSpan">parse</span>(urlStr, [parseQueryString], [slashesDenoteHost])

Take a URL string, and return an object.

Pass `true` as the second argument to also parse
the query string using the `querystring` module.
Defaults to `false`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.resolve" id="apidoc.element.url.resolve">
        function <span class="apidocSignatureSpan">url.</span>resolve
        <span class="apidocSignatureSpan">(source, relative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `host` will be used in place of `hostname` and `port`
* `pathname` is treated the same with or without the leading `/` (slash)
* `search` will be used in place of `query`
* `query` (object; see `querystring`) will only be used if `search` is absent.
* `search` is treated the same with or without the leading `?` (question mark)
* `hash` is treated the same with or without the leading `#` (pound sign, anchor)

### url.<span class="apidocCodeKeywordSpan">resolve</span>(from, to)

Take a base URL, and a href URL, and resolve them as a browser would for
an anchor tag.  Examples:

url.resolve(&#x27;/one/two/three&#x27;, &#x27;four&#x27;)         // &#x27;/one/two/four&#x27;
url.resolve(&#x27;http://example.com/&#x27;, &#x27;/one&#x27;)    // &#x27;http://example.com/one&#x27;
url.resolve(&#x27;http://example.com/one&#x27;, &#x27;/two&#x27;) // &#x27;http://example.com/two&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.resolveObject" id="apidoc.element.url.resolveObject">
        function <span class="apidocSignatureSpan">url.</span>resolveObject
        <span class="apidocSignatureSpan">(source, relative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//host and hostname are special, in this case a &#x27;&#x27; value is important
var emptyIsImportant = {&#x27;host&#x27;: true, &#x27;hostname&#x27;: &#x27;&#x27;};

//format: [from, path, expected]
relativeTests.forEach(function(relativeTest) {
test(&#x27;resolveObject(&#x27; + [relativeTest[0], relativeTest[1]] + &#x27;)&#x27;, function() {
var actual = url.<span class="apidocCodeKeywordSpan">resolveObject</span>(url.parse(relativeTest[0]), relativeTest[1]),
    expected = url.parse(relativeTest[2]);


assert.deepEqual(actual, expected);

expected = relativeTest[2];
actual = url.format(actual);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.url.Url" id="apidoc.module.url.Url">module url.Url</a></h1>


    <h2>
        <a href="#apidoc.element.url.Url.Url" id="apidoc.element.url.Url.Url">
        function <span class="apidocSignatureSpan">url.</span>Url
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.url.Url.prototype" id="apidoc.module.url.Url.prototype">module url.Url.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.url.Url.prototype.format" id="apidoc.element.url.Url.prototype.format">
        function <span class="apidocSignatureSpan">url.Url.prototype.</span>format
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function () {
  var auth = this.auth || &#x27;&#x27;;
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, &#x27;:&#x27;);
    auth += &#x27;@&#x27;;
  }

  var protocol = this.protocol || &#x27;&#x27;,
      pathname = this.pathname || &#x27;&#x27;,
      hash = this.hash || &#x27;&#x27;,
      host = false,
      query = &#x27;&#x27;;

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(&#x27;:&#x27;) === -1 ?
        this.hostname :
        &#x27;[&#x27; + this.hostname + &#x27;]&#x27;);
    if (this.port) {
      host += &#x27;:&#x27; + this.port;
    }
  }

  if (this.query &#x26;&#x26;
      util.isObject(this.query) &#x26;&#x26;
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query &#x26;&#x26; (&#x27;?&#x27; + query)) || &#x27;&#x27;;

  if (protocol &#x26;&#x26; protocol.substr(-1) !== &#x27;:&#x27;) protocol += &#x27;:&#x27;;

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) &#x26;&#x26; host !== false) {
    host = &#x27;//&#x27; + (host || &#x27;&#x27;);
    if (pathname &#x26;&#x26; pathname.charAt(0) !== &#x27;/&#x27;) pathname = &#x27;/&#x27; + pathname;
  } else if (!host) {
    host = &#x27;&#x27;;
  }

  if (hash &#x26;&#x26; hash.charAt(0) !== &#x27;#&#x27;) hash = &#x27;#&#x27; + hash;
  if (search &#x26;&#x26; search.charAt(0) !== &#x27;?&#x27;) search = &#x27;?&#x27; + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace(&#x27;#&#x27;, &#x27;%23&#x27;);

  return protocol + host + pathname + search + hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the query string using the `querystring` module.
Defaults to `false`.

Pass `true` as the third argument to treat `//foo/bar` as
`{ host: &#x27;foo&#x27;, pathname: &#x27;/bar&#x27; }` rather than
`{ pathname: &#x27;//foo/bar&#x27; }`. Defaults to `false`.

### url.<span class="apidocCodeKeywordSpan">format</span>(urlObj)

Take a parsed URL object, and return a formatted URL string.

* `href` will be ignored.
* `protocol` is treated the same with or without the trailing `:` (colon).
* The protocols `http`, `https`, `ftp`, `gopher`, `file` will be
  postfixed with `://` (colon-slash-slash).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.Url.prototype.parse" id="apidoc.element.url.Url.prototype.parse">
        function <span class="apidocSignatureSpan">url.Url.prototype.</span>parse
        <span class="apidocSignatureSpan">(url, parseQueryString, slashesDenoteHost)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError(&#x22;Parameter &#x27;url&#x27; must be a string, not &#x22; + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf(&#x27;?&#x27;),
      splitter =
          (queryIndex !== -1 &#x26;&#x26; queryIndex &#x3c; url.indexOf(&#x27;#&#x27;)) ? &#x27;?&#x27; : &#x27;#&#x27;,
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, &#x27;/&#x27;);
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like &#x22;  http://foo.com  \n&#x22;
  rest = rest.trim();

  if (!slashesDenoteHost &#x26;&#x26; url.split(&#x27;#&#x27;).length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = &#x27;&#x27;;
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it&#x27;s got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that&#x27;s
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === &#x27;//&#x27;;
    if (slashes &#x26;&#x26; !(proto &#x26;&#x26; hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &#x26;&#x26;
      (slashes || (proto &#x26;&#x26; !slashedProtocol[proto]))) {

    // there&#x27;s a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ =&#x3e; user:a@b host:c
    // http://a@b?@c =&#x3e; user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i &#x3c; hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 &#x26;&#x26; (hostEnd === -1 || hec &#x3c; hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf(&#x27;@&#x27;);
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d =&#x3e; host:b auth:a path:/c@d
      atSign = rest.lastIndexOf(&#x27;@&#x27;, hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i &#x3c; nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 &#x26;&#x26; (hostEnd === -1 || hec &#x3c; hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.p ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `hash`: The &#x27;fragment&#x27; portion of the URL including the pound-sign.

    Example: `&#x27;#hash&#x27;`

The following methods are provided by the URL module:

### url.<span class="apidocCodeKeywordSpan">parse</span>(urlStr, [parseQueryString], [slashesDenoteHost])

Take a URL string, and return an object.

Pass `true` as the second argument to also parse
the query string using the `querystring` module.
Defaults to `false`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.Url.prototype.parseHost" id="apidoc.element.url.Url.prototype.parseHost">
        function <span class="apidocSignatureSpan">url.Url.prototype.</span>parseHost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== &#x27;:&#x27;) {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.Url.prototype.resolve" id="apidoc.element.url.Url.prototype.resolve">
        function <span class="apidocSignatureSpan">url.Url.prototype.</span>resolve
        <span class="apidocSignatureSpan">(relative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `host` will be used in place of `hostname` and `port`
* `pathname` is treated the same with or without the leading `/` (slash)
* `search` will be used in place of `query`
* `query` (object; see `querystring`) will only be used if `search` is absent.
* `search` is treated the same with or without the leading `?` (question mark)
* `hash` is treated the same with or without the leading `#` (pound sign, anchor)

### url.<span class="apidocCodeKeywordSpan">resolve</span>(from, to)

Take a base URL, and a href URL, and resolve them as a browser would for
an anchor tag.  Examples:

url.resolve(&#x27;/one/two/three&#x27;, &#x27;four&#x27;)         // &#x27;/one/two/four&#x27;
url.resolve(&#x27;http://example.com/&#x27;, &#x27;/one&#x27;)    // &#x27;http://example.com/one&#x27;
url.resolve(&#x27;http://example.com/one&#x27;, &#x27;/two&#x27;) // &#x27;http://example.com/two&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.Url.prototype.resolveObject" id="apidoc.element.url.Url.prototype.resolveObject">
        function <span class="apidocSignatureSpan">url.Url.prototype.</span>resolveObject
        <span class="apidocSignatureSpan">(relative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk &#x3c; tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href=&#x22;&#x22; will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there&#x27;s nothing left to do here.
  if (relative.href === &#x27;&#x27;) {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes &#x26;&#x26; !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk &#x3c; rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== &#x27;protocol&#x27;)
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &#x26;&#x26;
        result.hostname &#x26;&#x26; !result.pathname) {
      result.path = result.pathname = &#x27;/&#x27;;
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol &#x26;&#x26; relative.protocol !== result.protocol) {
    // if it&#x27;s a known url protocol, then changing
    // the protocol does weird things
    // first, if it&#x27;s not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that&#x27;s known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v &#x3c; keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host &#x26;&#x26; !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || &#x27;&#x27;).split(&#x27;/&#x27;);
      while (relPath.length &#x26;&#x26; !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = &#x27;&#x27;;
      if (!relative.hostname) relative.hostname = &#x27;&#x27;;
      if (relPath[0] !== &#x27;&#x27;) relPath.unshift(&#x27;&#x27;);
      if (relPath.length &#x3c; 2) relPath.unshift(&#x27;&#x27;);
      result.pathname = relPath.join(&#x27;/&#x27;);
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || &#x27;&#x27;;
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || &#x27;&#x27;;
      var s = result.search || &#x27;&#x27;;
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname &#x26;&#x26; result.pathname.charAt(0) === &#x27;/&#x27;),
      isRelAbs = (
          relative.host ||
          relative.pathname &#x26;&#x26; relative.pathname.charAt(0) === &#x27;/&#x27;
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host &#x26;&#x26; relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname &#x26;&#x26; result.pathname.split(&#x27;/&#x27;) || [],
      relPath = relative.pathname &#x26;&#x26; relative.pathname.split(&#x27;/&#x27;) || [],
      psychotic = result.protocol &#x26;&#x26; !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = &#x27;&#x27;;
    result.port = null;
    if (result.host) {
      if (srcPath[0] === &#x27;&#x27;) srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = &#x27;&#x27;;
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//host and hostname are special, in this case a &#x27;&#x27; value is important
var emptyIsImportant = {&#x27;host&#x27;: true, &#x27;hostname&#x27;: &#x27;&#x27;};

//format: [from, path, expected]
relativeTests.forEach(function(relativeTest) {
test(&#x27;resolveObject(&#x27; + [relativeTest[0], relativeTest[1]] + &#x27;)&#x27;, function() {
var actual = url.<span class="apidocCodeKeywordSpan">resolveObject</span>(url.parse(relativeTest[0]), relativeTest[1]),
    expected = url.parse(relativeTest[2]);


assert.deepEqual(actual, expected);

expected = relativeTest[2];
actual = url.format(actual);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.url.util" id="apidoc.module.url.util">module url.util</a></h1>


    <h2>
        <a href="#apidoc.element.url.util.isNull" id="apidoc.element.url.util.isNull">
        function <span class="apidocSignatureSpan">url.util.</span>isNull
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNull = function (arg) {
  return arg === null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.util.isNullOrUndefined" id="apidoc.element.url.util.isNullOrUndefined">
        function <span class="apidocSignatureSpan">url.util.</span>isNullOrUndefined
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNullOrUndefined = function (arg) {
  return arg == null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.util.isObject" id="apidoc.element.url.util.isObject">
        function <span class="apidocSignatureSpan">url.util.</span>isObject
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObject = function (arg) {
  return typeof(arg) === &#x27;object&#x27; &#x26;&#x26; arg !== null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.util.isString" id="apidoc.element.url.util.isString">
        function <span class="apidocSignatureSpan">url.util.</span>isString
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (arg) {
  return typeof(arg) === &#x27;string&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
