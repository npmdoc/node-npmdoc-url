<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/defunctzombie/node-url#readme">url (v0.11.0)</a>
</h1>
<h4>The core `url` packaged standalone for use with Browserify.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.url">module url</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url">
            function <span class="apidocSignatureSpan">url.</span>Url
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.format">
            function <span class="apidocSignatureSpan">url.</span>format
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.parse">
            function <span class="apidocSignatureSpan">url.</span>parse
            <span class="apidocSignatureSpan">(url, parseQueryString, slashesDenoteHost)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.resolve">
            function <span class="apidocSignatureSpan">url.</span>resolve
            <span class="apidocSignatureSpan">(source, relative)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.resolveObject">
            function <span class="apidocSignatureSpan">url.</span>resolveObject
            <span class="apidocSignatureSpan">(source, relative)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">url.</span>Url.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">url.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.url.Url">module url.Url</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url.Url">
            function <span class="apidocSignatureSpan">url.</span>Url
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.url.Url.prototype">module url.Url.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url.prototype.format">
            function <span class="apidocSignatureSpan">url.Url.prototype.</span>format
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url.prototype.parse">
            function <span class="apidocSignatureSpan">url.Url.prototype.</span>parse
            <span class="apidocSignatureSpan">(url, parseQueryString, slashesDenoteHost)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url.prototype.parseHost">
            function <span class="apidocSignatureSpan">url.Url.prototype.</span>parseHost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url.prototype.resolve">
            function <span class="apidocSignatureSpan">url.Url.prototype.</span>resolve
            <span class="apidocSignatureSpan">(relative)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.Url.prototype.resolveObject">
            function <span class="apidocSignatureSpan">url.Url.prototype.</span>resolveObject
            <span class="apidocSignatureSpan">(relative)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.url.util">module url.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.util.isNull">
            function <span class="apidocSignatureSpan">url.util.</span>isNull
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.util.isNullOrUndefined">
            function <span class="apidocSignatureSpan">url.util.</span>isNullOrUndefined
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.util.isObject">
            function <span class="apidocSignatureSpan">url.util.</span>isObject
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.url.util.isString">
            function <span class="apidocSignatureSpan">url.util.</span>isString
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.url" id="apidoc.module.url">module url</a></h1>


    <h2>
        <a href="#apidoc.element.url.Url" id="apidoc.element.url.Url">
        function <span class="apidocSignatureSpan">url.</span>Url
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.format" id="apidoc.element.url.format">
        function <span class="apidocSignatureSpan">url.</span>format
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the query string using the `querystring` module.
Defaults to `false`.

Pass `true` as the third argument to treat `//foo/bar` as
`{ host: 'foo', pathname: '/bar' }` rather than
`{ pathname: '//foo/bar' }`. Defaults to `false`.

### url.<span class="apidocCodeKeywordSpan">format</span>(urlObj)

Take a parsed URL object, and return a formatted URL string.

* `href` will be ignored.
* `protocol` is treated the same with or without the trailing `:` (colon).
* The protocols `http`, `https`, `ftp`, `gopher`, `file` will be
  postfixed with `://` (colon-slash-slash).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.parse" id="apidoc.element.url.parse">
        function <span class="apidocSignatureSpan">url.</span>parse
        <span class="apidocSignatureSpan">(url, parseQueryString, slashesDenoteHost)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url &amp;&amp; util.isObject(url) &amp;&amp; url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `hash`: The 'fragment' portion of the URL including the pound-sign.

    Example: `'#hash'`

The following methods are provided by the URL module:

### url.<span class="apidocCodeKeywordSpan">parse</span>(urlStr, [parseQueryString], [slashesDenoteHost])

Take a URL string, and return an object.

Pass `true` as the second argument to also parse
the query string using the `querystring` module.
Defaults to `false`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.resolve" id="apidoc.element.url.resolve">
        function <span class="apidocSignatureSpan">url.</span>resolve
        <span class="apidocSignatureSpan">(source, relative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `host` will be used in place of `hostname` and `port`
* `pathname` is treated the same with or without the leading `/` (slash)
* `search` will be used in place of `query`
* `query` (object; see `querystring`) will only be used if `search` is absent.
* `search` is treated the same with or without the leading `?` (question mark)
* `hash` is treated the same with or without the leading `#` (pound sign, anchor)

### url.<span class="apidocCodeKeywordSpan">resolve</span>(from, to)

Take a base URL, and a href URL, and resolve them as a browser would for
an anchor tag.  Examples:

url.resolve('/one/two/three', 'four')         // '/one/two/four'
url.resolve('http://example.com/', '/one')    // 'http://example.com/one'
url.resolve('http://example.com/one', '/two') // 'http://example.com/two'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.resolveObject" id="apidoc.element.url.resolveObject">
        function <span class="apidocSignatureSpan">url.</span>resolveObject
        <span class="apidocSignatureSpan">(source, relative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//host and hostname are special, in this case a '' value is important
var emptyIsImportant = {'host': true, 'hostname': ''};

//format: [from, path, expected]
relativeTests.forEach(function(relativeTest) {
test('resolveObject(' + [relativeTest[0], relativeTest[1]] + ')', function() {
var actual = url.<span class="apidocCodeKeywordSpan">resolveObject</span>(url.parse(relativeTest[0]), relativeTest[1]),
    expected = url.parse(relativeTest[2]);


assert.deepEqual(actual, expected);

expected = relativeTest[2];
actual = url.format(actual);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.url.Url" id="apidoc.module.url.Url">module url.Url</a></h1>


    <h2>
        <a href="#apidoc.element.url.Url.Url" id="apidoc.element.url.Url.Url">
        function <span class="apidocSignatureSpan">url.</span>Url
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.url.Url.prototype" id="apidoc.module.url.Url.prototype">module url.Url.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.url.Url.prototype.format" id="apidoc.element.url.Url.prototype.format">
        function <span class="apidocSignatureSpan">url.Url.prototype.</span>format
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &amp;&amp;
      util.isObject(this.query) &amp;&amp;
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query &amp;&amp; ('?' + query)) || '';

  if (protocol &amp;&amp; protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) &amp;&amp; host !== false) {
    host = '//' + (host || '');
    if (pathname &amp;&amp; pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash &amp;&amp; hash.charAt(0) !== '#') hash = '#' + hash;
  if (search &amp;&amp; search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the query string using the `querystring` module.
Defaults to `false`.

Pass `true` as the third argument to treat `//foo/bar` as
`{ host: 'foo', pathname: '/bar' }` rather than
`{ pathname: '//foo/bar' }`. Defaults to `false`.

### url.<span class="apidocCodeKeywordSpan">format</span>(urlObj)

Take a parsed URL object, and return a formatted URL string.

* `href` will be ignored.
* `protocol` is treated the same with or without the trailing `:` (colon).
* The protocols `http`, `https`, `ftp`, `gopher`, `file` will be
  postfixed with `://` (colon-slash-slash).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.Url.prototype.parse" id="apidoc.element.url.Url.prototype.parse">
        function <span class="apidocSignatureSpan">url.Url.prototype.</span>parse
        <span class="apidocSignatureSpan">(url, parseQueryString, slashesDenoteHost)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 &amp;&amp; queryIndex &lt; url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost &amp;&amp; url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes &amp;&amp; !(proto &amp;&amp; hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &amp;&amp;
      (slashes || (proto &amp;&amp; !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ =&gt; user:a@b host:c
    // http://a@b?@c =&gt; user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i &lt; hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 &amp;&amp; (hostEnd === -1 || hec &lt; hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d =&gt; host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i &lt; nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 &amp;&amp; (hostEnd === -1 || hec &lt; hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.p ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* `hash`: The 'fragment' portion of the URL including the pound-sign.

    Example: `'#hash'`

The following methods are provided by the URL module:

### url.<span class="apidocCodeKeywordSpan">parse</span>(urlStr, [parseQueryString], [slashesDenoteHost])

Take a URL string, and return an object.

Pass `true` as the second argument to also parse
the query string using the `querystring` module.
Defaults to `false`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.Url.prototype.parseHost" id="apidoc.element.url.Url.prototype.parseHost">
        function <span class="apidocSignatureSpan">url.Url.prototype.</span>parseHost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.Url.prototype.resolve" id="apidoc.element.url.Url.prototype.resolve">
        function <span class="apidocSignatureSpan">url.Url.prototype.</span>resolve
        <span class="apidocSignatureSpan">(relative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `host` will be used in place of `hostname` and `port`
* `pathname` is treated the same with or without the leading `/` (slash)
* `search` will be used in place of `query`
* `query` (object; see `querystring`) will only be used if `search` is absent.
* `search` is treated the same with or without the leading `?` (question mark)
* `hash` is treated the same with or without the leading `#` (pound sign, anchor)

### url.<span class="apidocCodeKeywordSpan">resolve</span>(from, to)

Take a base URL, and a href URL, and resolve them as a browser would for
an anchor tag.  Examples:

url.resolve('/one/two/three', 'four')         // '/one/two/four'
url.resolve('http://example.com/', '/one')    // 'http://example.com/one'
url.resolve('http://example.com/one', '/two') // 'http://example.com/two'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.Url.prototype.resolveObject" id="apidoc.element.url.Url.prototype.resolveObject">
        function <span class="apidocSignatureSpan">url.Url.prototype.</span>resolveObject
        <span class="apidocSignatureSpan">(relative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk &lt; tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes &amp;&amp; !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk &lt; rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &amp;&amp;
        result.hostname &amp;&amp; !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol &amp;&amp; relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v &lt; keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host &amp;&amp; !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length &amp;&amp; !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length &lt; 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname &amp;&amp; result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname &amp;&amp; relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host &amp;&amp; relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname &amp;&amp; result.pathname.split('/') || [],
      relPath = relative.pathname &amp;&amp; relative.pathname.split('/') || [],
      psychotic = result.protocol &amp;&amp; !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//host and hostname are special, in this case a '' value is important
var emptyIsImportant = {'host': true, 'hostname': ''};

//format: [from, path, expected]
relativeTests.forEach(function(relativeTest) {
test('resolveObject(' + [relativeTest[0], relativeTest[1]] + ')', function() {
var actual = url.<span class="apidocCodeKeywordSpan">resolveObject</span>(url.parse(relativeTest[0]), relativeTest[1]),
    expected = url.parse(relativeTest[2]);


assert.deepEqual(actual, expected);

expected = relativeTest[2];
actual = url.format(actual);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.url.util" id="apidoc.module.url.util">module url.util</a></h1>


    <h2>
        <a href="#apidoc.element.url.util.isNull" id="apidoc.element.url.util.isNull">
        function <span class="apidocSignatureSpan">url.util.</span>isNull
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNull = function (arg) {
  return arg === null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.util.isNullOrUndefined" id="apidoc.element.url.util.isNullOrUndefined">
        function <span class="apidocSignatureSpan">url.util.</span>isNullOrUndefined
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNullOrUndefined = function (arg) {
  return arg == null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.util.isObject" id="apidoc.element.url.util.isObject">
        function <span class="apidocSignatureSpan">url.util.</span>isObject
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObject = function (arg) {
  return typeof(arg) === 'object' &amp;&amp; arg !== null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.url.util.isString" id="apidoc.element.url.util.isString">
        function <span class="apidocSignatureSpan">url.util.</span>isString
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isString = function (arg) {
  return typeof(arg) === 'string';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>